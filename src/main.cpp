#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#include <stdint.h>

#include <cmath>
#include <vector>

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "util/stb_image_write.h"

#if _WIN32
#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <Windows.h>
#endif

#include "maths/vec.h"

#include "Palettes.h"



struct sRGBPixel
{
	uint8_t r;
	uint8_t g;
	uint8_t b;
	uint8_t a;
};


void tonemap(std::vector<sRGBPixel> & image_LDR, const std::vector<vec3f> & image_HDR, const int passes, const int xres, const int yres) noexcept
{
	const auto sRGB = [](float u) -> float { return (u <= 0.0031308f) ? 12.92f * u : 1.055f * std::pow(u, 0.416667f) - 0.055f; };
	const float scale = 1.0f / passes;

	#pragma omp parallel for
	for (int y = 0; y < yres; y++)
	for (int x = 0; x < xres; x++)
	{
		const int pixel_idx = y * xres + x;
		vec3f pixel_colour = image_HDR[pixel_idx] * scale;

		image_LDR[pixel_idx] =
		{
			(uint8_t)std::max(0.0f, std::min(255.0f, sRGB(pixel_colour.x()) * 256)),
			(uint8_t)std::max(0.0f, std::min(255.0f, sRGB(pixel_colour.y()) * 256)),
			(uint8_t)std::max(0.0f, std::min(255.0f, sRGB(pixel_colour.z()) * 256)),
			255
		};
	}
}


template<int b>
constexpr inline double RadicalInverse(int i)
{
	constexpr double inv_b = 1.0 / b;

	double f = 1, r = 0;
	while (i > 0)
	{
		const int i_div_b = i / b;
		const int i_mod_b = i - b * i_div_b;

		f *= inv_b;
		r += i_mod_b * f;
		i  = i_div_b;
	}
	return r;
}


// Hash function by Thomas Wang: https://burtleburtle.net/bob/hash/integer.html
inline uint32_t hash(uint32_t x)
{
	x  = (x ^ 12345391) * 2654435769;
	x ^= (x << 6) ^ (x >> 26);
	x *= 2654435769;
	x += (x << 5) ^ (x >> 12);

	return x;
}


inline real wrap1r(real u, real v) { return (u + v < 1) ? u + v : u + v - 1; }


inline real sign(real v) { return (v >= 0) ? (real)1 : (real)-1; }

// Convert uniform distribution into triangle-shaped distribution
// From https://www.shadertoy.com/view/4t2SDh
inline real triDist(real v)
{
	const real orig = v * 2 - 1;
	v = orig / std::sqrt(std::fabs(orig));
	v = std::max((real)-1, v); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!
	v = v - sign(orig);

	return v;
}


int main(int argc, char ** argv)
{
#if _WIN32
	SetPriorityClass(GetCurrentProcess(), BELOW_NORMAL_PRIORITY_CLASS);
#endif

	constexpr int xres = 512 * 1;
	constexpr int yres = 512 * 1;

	std::vector<vec3f>     image_hdr(xres * yres);
	std::vector<sRGBPixel> image_ldr(xres * yres);

	const auto save_tonemapped_buffer = [&](const char * channel_name, const int frame, const int passes, const std::vector<vec3f> & buffer)
	{
		// Tonemap and convert to LDR sRGB
		tonemap(image_ldr, buffer, passes, xres, yres);

		// Save frame
		char filename[128];
		snprintf(filename, 128, "../frames/%s_frame_%08d.png", channel_name, frame);
		stbi_write_png(filename, xres, yres, 4, &image_ldr[0], xres * 4);
		printf("Saved %s with %d passes\n", filename, passes);
	};

	constexpr int num_frames = 60 * 2;

	const     int num_samples = int(std::pow(6.0, 3.0)); // Use 6^4 for final render
	constexpr int num_iters = 50;

	const     double inv_num_samples = 1.0 / num_samples;
	constexpr double inv_xres = 1.0 / xres;
	constexpr double inv_yres = 1.0 / yres;
	constexpr double aspect   = yres * inv_xres;
	constexpr double scale    = 1;

#if _WIN32
	const double t0 = (double)GetTickCount();
#endif
	for (int frame = 0; frame < num_frames; ++frame)
	{
		const int pal_idx = 427 - 1; //frame;
		constexpr int pal_size = 5;
		vec3f pal[pal_size];
		for (int i = 0; i < pal_size; ++i)
		{
			const int r = (palettes[pal_idx][i] & 0x0000ff) >> 0;
			const int g = (palettes[pal_idx][i] & 0x00ff00) >> 8;
			const int b = (palettes[pal_idx][i] & 0xff0000) >> 16;
			const vec3f v = vec3f(r, g, b) / 255.0f;
			pal[i] = v * v * v; // Approx inverse gamma
		}


		const int    seed = 427 - 1;
		const vec2d  k0   = vec2d(RadicalInverse<2>(seed), RadicalInverse<3>(seed)) * 0.2 - 0.1;
		const double pdj_scale = (RadicalInverse<3>(seed) + 0.5) / two_pi;

		#pragma omp parallel for
		for (int y = 0; y < yres; y++)
		for (int x = 0; x < xres; x++)
		{
			const int       pixel_idx = y * xres + x;
			const double pixel_sample = hash(pixel_idx) * (1.0 / (1ull << 32));

			vec3f sample_sum(0);
			for (int i = 0; i < num_samples; ++i)
			{
				const double time_u = wrap1r(pixel_sample, i * inv_num_samples) * 1.0;
				const double t = (frame + 0.5 + triDist(time_u)) / num_frames;
				const vec2d u(
					wrap1r(pixel_sample, RadicalInverse<2>(i)),
					wrap1r(pixel_sample, RadicalInverse<3>(i))
				);
				vec2d p(
					1 - 2 * (x + 0.5 + triDist(u.x())) * inv_xres,
					1 - 2 * (y + 0.5 + triDist(u.y())) * inv_yres);
				p.y() *= aspect;
				p *= scale;

				const double a = t * two_pi;
				const vec2d  k = k0 + vec2d(std::cos(a), std::sin(a)) * 0.035;

				const vec2d centre(0);
				const double distance0 = length(p - centre) * 5 + 1;

				for (int z = 0; z < num_iters; z++)
				{
					const vec2d sin_swapped(
						std::sin(two_pi * p.y()),
						std::sin(two_pi * p.x()));
					p += k - sin_swapped * pdj_scale;
				}

				sample_sum += pal[(int)std::floor(length(p) / distance0 * 3) % pal_size];
			}

			image_hdr[pixel_idx] = sample_sum;
		}

		save_tonemapped_buffer("pdj", frame, num_samples, image_hdr);
	}

#if _WIN32
	const double t1 = (double)GetTickCount();
	printf("Took %f seconds\n", (t1 - t0) * 0.001);
#endif
	return 0;
}
